################################################################################

_ROOT="$(realpath "$0")"
_ROOT="${_ROOT%/*}"
srcdir=src
pkgdir=pkg

DLAGENTS=('ftp::/usr/bin/curl -fC - --ftp-pasv --retry 3 --retry-delay 3 -o %o %u'
          'http::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
          'https::/usr/bin/curl -fLC - --retry 3 --retry-delay 3 -o %o %u'
          'rsync::/usr/bin/rsync -z %u %o'
          'scp::/usr/bin/scp -C %u %o')

INDENT='    '
msg ()
{
    echo "$(tput bold)$(tput setf 2)==>$(tput setf 7) $1"
    shift 1
    for i; do
        echo "${INDENT}$i"
    done
    echo -n "$(tput sgr0)"
}

msg2 ()
{
    echo "$(tput bold)$(tput setf 1)  ->$(tput setf 7) $1"
    shift 1
    for i; do
        echo "${INDENT}$i"
    done
    echo -n "$(tput sgr0)"
}

warning ()
{
    echo "$(tput bold)$(tput setf 6)==> WARNING:$(tput setf 7) $1"
    shift 1
    for i; do
        echo "${INDENT}$i"
    done
    echo -n "$(tput sgr0)"
}

error ()
{
    echo "$(tput bold)$(tput setf 4)==> ERROR:$(tput setf 7) $1"
    shift 1
    for i; do
        echo "${INDENT}$i"
    done
    echo -n "$(tput sgr0)"
}

_init()
{
    mkdir -p "$_ROOT/$srcdir"
    mkdir -p "$_ROOT/$pkgdir"

    srcdir="$(realpath "$srcdir")"
    pkgdir="$(realpath "$pkgdir")"
}

_listdeps()
{
    msg "$pkgname $pkgver-$pkgrel"
    msg "Runtime dependencies"
    printf -- '%s\n' "${depends[@]}"
    msg "Buildtime dependencies"
    printf -- '%s\n' "${makedepends[@]}"
    msg "Optional dependencies"
    printf -- '%s\n' "${optdepends[@]}"
}

_fetch()
{
    msg "Retrieving sources..."

    for URI in "${source[@]}"; do
        case "$URI" in
            http://*|https://*|ftp://*)
                FILE="${URI##*/}"

                ## TODO: add support for DLAGENT
                msg2 "Downloading $FILE..."
                wget "$OPT_FORCE" "$URI" -O "$FILE"

                ## Strangely enough, wget will not return 0 on success. On error, it
                ## will still create a 0-byte file.
                if [ $(du -sb "$FILE" | awk '{print $1}') -eq 0 ]; then
                    error "Failure while downloading $FILE" "Aborting..."
                    exit 1
                fi
                ;;
            git+*)
                GITURI="${URI#git+}"
                if [ -d "$_gitname/.git" ]; then
                    cd "$_gitname"
                    git pull
                else
                    git clone "$GITURI"
                fi
                ;;
            *)
                error "Unkown protocol"
        esac
    done
}

_checksum ()
{
    if $OPT_CHECKSKIP; then
        warning "Skipping verification of source file checksums."
        return
    fi

    RESULT=true

    case ${#source[*]} in
        ${#md5sums[*]})
            CHECKSUMMER=md5sum;;
        ${#sha1sums[*]})
            CHECKSUMMER=sha1sum;;
        ${#sha256sums[*]})
            CHECKSUMMER=sha256sum;;
        ${#sha384sums[*]})
            CHECKSUMMER=sha384sum;;
        ${#sha512sums[*]})
            CHECKSUMMER=sha512sum;;
        *)
            error "Integrity checks are either missing or differ in size."
            exit 1;;
    esac

    msg "Validating source files with ${CHECKSUMMER}s..."

    ## Here we need to use a numeric index to browse arrays to make sure we get
    ## same index for both arrays.
    ## WARNING: this will only work in bash because indexing start at 0.
    for i in $(seq 0 $((${#source[@]} -1))); do

        eval test '${'${CHECKSUMMER}'s[$i]}' = 'SKIP'
        if [ $? -eq 0 ]; then
            echo "Skipped"
            continue
        fi

        FILE="${source[$i]##*/}"
        if [ ! -f "$FILE" ]; then
            error "$FILE was not found in the build directory and is not a URL."
            exit
        fi

        CHECKSUM="$($CHECKSUMMER "$FILE" | cut -f1 -d' ')"

        echo -n "$INDENT$FILE ... "

        ## Note: here we take care to control expansion at the right time.
        eval test '$CHECKSUM' = '${'${CHECKSUMMER}'s[$i]}'
        if [ $? -eq 0 ]; then
            echo "Passed"
        else
            echo "FAILED"
            RESULT=false
        fi


    done

    if ! $RESULT; then
        error "One or more files did not pass the validity check!"
        exit 1
    fi
}

_extract ()
{
    msg "Extracting sources..."
    for URI in "${source[@]}"; do
        FILE="${URI##*/}"
	    case "$FILE" in
		    *.tar.bz2|*.tbz2)
                msg2 "Extracting $FILE with tar"
                tar xjf "$FILE" -C "$srcdir";;
		    *.tar.gz|*.tgz)
                msg2 "Extracting $FILE with tar"
                tar xzf "$FILE" -C "$srcdir";;
		    *.tar.xz|*.txz)
                msg2 "Extracting $FILE with tar"
                tar xJf "$FILE" -C "$srcdir";;
            *)
                case "$URI" in
                    git+*)
                        ln -sf "../$_gitname" "$srcdir";;
                esac
	    esac
    done
}

_buildhook()
{
    msg "Starting build()..."
    (cd "$srcdir" && build)
}

_tidying ()
{
    for i in "${options[@]}"; do
        if [ "$(echo $i | sed 's/\(.\).*/\1/')" = "!" ]; then
            eval TIDY_$(echo $i | sed 's/^!//')=false
        else
            eval TIDY_$i=true
        fi
    done

    if $TIDY_purge; then
        msg2 "Purging unwanted files..."
        find * -type f \( -name '.packlist' -o -name '*.pod' \) -delete
            rm -f "usr/share/info/dir" "usr/info/dir"
    fi
    if $TIDY_docs; then
        msg2 "Compressing man and info pages..."
        find * -type f -name '*.[0-9]' -exec gzip {} \;
    fi
    if $TIDY_strip; then
        msg2 "Stripping unneeded symbols from binaries and libraries..."
        find * -type f -executable -exec strip -s {} \;
    fi

    ## We make sure folder permissions are world accessible.
    find * -type d -exec chmod o+rx {} \;
}

_compress()
{
    msg "Creating package \"$pkgname\"..."

    UNINS="$pkgname-$pkgver-$pkgrel-uninstall.sh"
    msg2 "Generating $UNINS..."
    echo '#!/bin/sh' > "$UNINS"
    (cd "$pkgdir" && \
        find * -type f -exec echo "rm /"{} \; >> "../$UNINS" && \
        find * -type d -exec echo "rmdir /"{} \; >> "../$UNINS"
    )
    chmod +x "$UNINS"

    msg2 "Compressing package..."
    (cd "$pkgdir" && tar --owner=root --group=root -cJf "../$pkgname-$pkgver-$pkgrel-$(uname -m).tar.xz" *)
}

_packagehook()
{
    if $OPT_NOCLOBBER && [ $(ls -a1 "$pkgdir" | wc -l) -ne 2 ]; then
        error "A package has already been built. (use -f to overwrite)"
        exit 1
    fi

    rm -rf "$pkgdir"

    msg "Starting package()..."
    (cd "$srcdir" && package)

    msg "Tidying install..."
    (cd "$pkgdir" && umask 022 && _tidying)

    _compress
}

_clean ()
{
    msg "Cleaning up..."
    rm -r "$srcdir" "$pkgdir"
}

_install()
{
    msg "Installing package $pkgname..."
    ## TODO: make sure permissions are fixed.
    # sudo tar xf "$pkgname-$pkgver-$pkgrel.tar.xz" -C "/"
}

_printhelp ()
{
    cat <<EOE
Usage: ${1##*/} [OPTIONS]

Port builder for $pkgname $pkgver.

This script can perform multiple operations:
  1. Fetch source code.
  2. Build.
  3. Create package.
  4. Clean folder from build data.
Default operation is to fetch source code if required.

Options:

  -b:  Build.
  -c:  Clean source folders from temp file (keep upstream source and built package).
  -d:  List dependencies and exit.
  -f:  Force operation (overwrite, rebuild, reinstall).
  -h:  Display this help.
  -i:  Install.
  -R:  Create package.
  -s:  Skip integrity checks.

EOE
}

OPT_FORCE="-nc"
OPT_NOCLOBBER=true

OPT_BUILD=false
OPT_PACKAGE=false
OPT_INSTALL=false
OPT_CLEAN=false
OPT_CHECKSKIP=false

#-- strip:     Strip symbols from binaries/libraries
#-- docs:      Save doc directories specified by DOC_DIRS
#-- libtool:   Leave libtool (.la) files in packages
#-- emptydirs: Leave empty directories in packages
#-- zipman:    Compress manual (man and info) pages in MAN_DIRS with gzip
#-- purge:     Remove files specified by PURGE_TARGETS
#-- upx:       Compress binary executable files using UPX
TIDY_strip=true
TIDY_docs=true
TIDY_libtool=true
TIDY_emptydirs=true
TIDY_zipman=true
TIDY_purge=true
TIDY_upx=false

while getopts ":bcdfhiRs" opt; do
    case $opt in
        b)
            OPT_BUILD=true ;;
        c)
            OPT_CLEAN=true ;;
        d)
            _listdeps
            exit;;
        f)
            OPT_FORCE=""
            OPT_NOCLOBBER=false ;;
        h)
            _printhelp "$0"
            exit 1 ;;
        i)
            OPT_INSTALL=true ;;
        R)
            OPT_PACKAGE=true ;;
        s)
            OPT_CHECKSKIP=true ;;
        ?)
            _printhelp "$0"
            exit 1 ;;
        :)
            echo "Missing argument."
            _printhelp "$0"
            exit 1 ;;
    esac
done
shift $(($OPTIND - 1))

msg "Making package: $pkgname $pkgver-$pkgrel ($(date))"

_init
_fetch
_extract
_checksum

if $OPT_BUILD; then _buildhook; fi
if $OPT_PACKAGE; then _packagehook; fi
if $OPT_INSTALL; then _install; fi
if $OPT_CLEAN; then _clean; fi

msg "Finished making: $pkgname ${pkgver}-$pkgrel ($(date))"
