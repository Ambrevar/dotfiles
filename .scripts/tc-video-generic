#!/bin/sh

## TODO: handle srt encoding.

_printhelp()
{
    cat <<EOF
Usage: ${1##*/} [OPTIONS] FILES|FOLDERS

Transcode FILES or files found in FOLDERS to .mkv with x264 and ogg. Black
stripes are *not* cropped by default since it may be sometimes
inaccurate. Output files are the same as the original, with time appended.

Options:
  -b:      Default bitrate for audio stream with unidentifiable bitrate. If 0,
           copy stream (default).
  -c:      Copy streams (no reencoding).
  -C:      Enable auto-crop (needs video reencoding).
  -f:      Remove source when done.
  -h:      Display this help.
  -o OPT:  Additional options.
  -p:      Preview changes, do not encode.
  -s:      Sample of 5 minutes.
  -S MIN:  Sample of MIN minutes.
  -t:      Remove all "title" metadata.

User options are read from variable TC_VIDEO_OPT. This can be useful if you
always use the same options.

Examples:

* Exchange stream 1 an 2 by first removing them, then reading them in the
  desired order.

  ${1##*/} -o '-map -0:1 -map -0:2 -map 0:2 -map 0:1' input.mkv

* Change audio stream 1 title and remove audio stream 2 title:

  ${1##*/} -o '-metadata:s:a:0 title="FR: OGG Stereo" -metadata:s:a:1 title=' input.mkv

EOF
}

SAMPLE=""
pVIDEO_FILTER=""
VIDEO_PARAM="-c:v libx264 -preset slow -crf 20"
AUDIO_PARAM=""
AUDIO_CODEC="libvorbis"
AUDIO_DEFAULT_RATE=0

## What to do if file exists:
# -y overwrite
# -n do not overwrite.
OVERWRITE="-n"
OPT_OVERWRITE=false

OPT_REMOVE_TITLE=false
OPT_CROP=false
OPT_PREVIEW=false

while getopts ":b:cCfho:psS:t" opt; do
    case $opt in
        b)
            AUDIO_DEFAULT_RATE=$OPTARG ;;
        c)
            VIDEO_PARAM="-c:v copy"
            AUDIO_PARAM="-c:a copy" ;;
        C)
            OPT_CROP=true;;
        f)
            OVERWRITE="-y"
            OPT_OVERWRITE=true;;
        h)
            _printhelp "$0"
            exit 1 ;;
        o)
            TC_VIDEO_OPT="$OPTARG" ;;
        p)
            OPT_PREVIEW=true ;;
        s)
            SAMPLE="-ss 60 -t 360" ;;
        S)
            SAMPLE="-ss 60 -t $((60*$OPTARG))" ;;
        t)
            OPT_REMOVE_TITLE=true ;;
        ?)
            _printhelp "$0"
            exit 1 ;;
        :)
            echo "Missing argument."
            _printhelp "$0"
            exit 1 ;;
    esac
done

shift $(($OPTIND - 1))


if [ $# -eq 0 ]; then
    _printhelp "$0"
    exit
fi

if [ -z "$(command -v ffmpeg)" ]; then
    echo "ffmpeg required."
    exit
fi

_duration()
{
    ## In seconds.
    ffmpeg -i "$1" 2>&1 </dev/null | awk '/Duration/ {split($2, time, /:|\./); print time[1]*60*60 + time[2]*60 + time[3]}'
}

_highfreq()
{
    awk 'BEGIN{max=0} /crop=/ {t[$NF]++; if (t[$NF]>max) {max=t[$NF]; val=$NF}} END{print val}'
}

_cropvalue()
{
    ## For 5 different timeslices of 1 second at every 1/6th of the video, we
    ## sample the crop values. We keep the values with highest frequency.
    STEP=$(($(_duration "$1")/6))
    for i in $(seq $STEP $STEP $((5*$STEP))); do
        ffmpeg -ss $i -t 10 -i "$1" -vf "cropdetect=24:2:0" -f null - 2>&1 </dev/null
    done | _highfreq
}

_audiobitrate()
{
    ## As of 2013-10-23, ffmpeg sucks at retrieving audio bitrate. Therefore we
    ## use mediainfo if available, ffmpeg otherwise.

    ## In the end, if some stream bitrates are missing, we have two
    ## possibilities: either we copy the stream (default), or we encode it to a
    ## default value.

    ## AWK note: in "(bitrate+0 > 500)", the +0 is required to make sure bitrate is numeric.
    if [ -n "$(command -v mediainfo)" ]; then
        mediainfo "$1" | awk -v codec="$AUDIO_CODEC" -v bitrate="$AUDIO_DEFAULT_RATE" 'BEGIN {id=0} /^Audio/ { getline; while(getline && ! index($0,"Bit rate  ")); if($4) printf "-c:a:" id " " codec " -b:a:" id " " $4 "k " ; else if (bitrate > 0) printf "-c:a:" id " " codec " -b:a:" id " " bitrate "k "; else printf "-c:a:" id " copy "; id++} END {print ""}'
    else
        ffmpeg -i "$1" 2>&1 </dev/null | awk -v codec="$AUDIO_CODEC" -v bitrate="$AUDIO_DEFAULT_RATE" 'BEGIN {id=0} /^ *Stream.*Audio/ {match($0, / [^ ]+ kb\/s/); res=substr($0, RSTART+1, RLENGTH-6); if(res || bitrate) {if(res) bitrate=res; if(bitrate+0 > 500) bitrate=500; printf "-c:a:" id " " codec " -b:a:" id " " bitrate "k "} else printf "-c:a:" id " copy "; id++} END {print ""}'
    fi

    ## TODO: use 2 awk calls.
}

_tc_transcode()
{
    echo "==> [$1]"
    OUTPUT="${1%.*}-$(date '+%F-%H%M%S').mkv"

    STREAM_TITLE=""
    if $OPT_REMOVE_TITLE; then
        STREAM_NUM=$(ffmpeg -i "$1" 2>&1 </dev/null| grep -c 'Stream')
        for i in $(seq 0 $STREAM_NUM); do
            STREAM_TITLE="${STREAM_TITLE}-metadata:s:$i title= "
        done
    fi

    if $OPT_CROP; then
        echo "Computing crop values... "
        VIDEO_FILTER="-vf $(_cropvalue "$1")"
    fi


    ## Only set AUDIO_PARAM if not already set.
    if [ -z "$AUDIO_PARAM" ]; then
        ## WARNING: we mix down audio to 2 channels with '-ac 2'. This greatly
        ## reduce file size and avoid any confusion for playback, which is often
        ## the case when converting DTS to any other format because DTS has
        ## embedded channel description which is not available in these formats.
        # AUDIO_FILTER="-ac 2"
        AUDIO_PARAM="$(_audiobitrate "$1") -ac 2"
    fi

    cat<<EOF
================================================================================
User options:  ${TC_VIDEO_OPT:-none}
Sample:        ${SAMPLE:-no}
Clear tags:    $OPT_REMOVE_TITLE
In place:      $OPT_OVERWRITE
Crop:          $OPT_CROP
Video param:   $VIDEO_PARAM
Video filter:  $VIDEO_FILTER
Audio param:   $AUDIO_PARAM
================================================================================
EOF

    $OPT_PREVIEW && exit

    ## Zsh compatibility. We need it otherwise word splitting of parameter like
    ## SAMPLE will not work.
    STATUS="$(set -o | grep 'shwordsplit' | awk '{print $2}')"
    [ "$STATUS" = "off" ] && set -o shwordsplit

    ffmpeg $OVERWRITE -i "$1" \
        $VIDEO_PARAM $VIDEO_FILTER \
        $AUDIO_PARAM \
        -c:s copy \
        -map 0 $STREAM_TITLE \
        $SAMPLE $TC_VIDEO_OPT "$OUTPUT" </dev/null

    ## Restore Zsh previous options. This will not turn off shwordsplit if it
    ## was on before calling the function.
    [ "$STATUS" = "off" ] && set +o shwordsplit

    if $OPT_OVERWRITE; then
        rm -f "$1"
        mv -f "$OUTPUT" "${1%.*}.mkv"
    fi
    echo
}

for i in "$@"; do

    ## Argument is a folder. We search for all video files in there.
    if [ -d "$i" ]; then

        ## WARNING: ffmpeg continues to read stdin once it has started, so it should
        ## not be called from within a while<<EOF loop without redirecting stdin.
        while IFS= read -r i; do
            _tc_transcode "$j"
            done<<EOF
$(find "$i"  \( \
            -iname '*.mkv' -o \
            -iname '*.mp4' -o \
            -iname '*.avi' -o \
            -iname '*.webm' -o \
            -iname '*.flv' -o \
            -iname '*.wmv' -o \
            -iname '*.mpg' \) )
EOF

    else
        ## Argument is a regular file.
        _tc_transcode "$i"
    fi

done
