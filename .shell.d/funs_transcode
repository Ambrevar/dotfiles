## -*- mode:sh -*- #
################################################################################
## Shell -- Trancode function set.
## Date 2013-01-27
################################################################################

## Tool list: ffmpeg, recode, titlecase.awk

## Support:
# ffmpeg -codecs
# ffmpeg -formats

## Useful guides
## x264: http://ffmpeg.org/trac/ffmpeg/wiki/x264EncodingGuide
## ID3 details: http://en.wikipedia.org/wiki/ID3

################################################################################
## Text

tc_text_scan ()
{
    local IFS
    IFS="
"

    for i in $(find . -type f -size -50M -print); do
        echo -n "# "
        file "$i"
        grep -m1 "\`" "$i"
        grep -m1 "oe" "$i"
    done
}

## Confert all 'bad' encoding to UTF-8/LF.
##
## WARNING: It will fail for encoding other than ISO-8859-1 and cp1252.
tc_text_2utf8 ()
{
    local CODING
    local IFS
    IFS="
"

    for i in $(find . -type f -size -50M -print); do
        CODING=$(file "$i")

        if [ -n "$(echo $CODING | grep 'ISO-8859')" ]; then
            echo "ISO-8859:   [$i]"
            recode latin1..utf-8 "$i"

        elif [ -n "$(echo $CODING | grep 'Non-ISO extended-ASCII')" ]; then
            echo "cp1252:     [$i]"
            recode cp1252..utf-8 "$i"

        elif [ -n "$(echo $CODING | grep 'UTF-16 Unicode text')" ]; then
            echo "UTF-16:     [$i]"
            recode utf-16..utf-8 "$i"

        elif [ -n "$(echo $CODING | grep 'UTF-8 Unicode (with BOM)')" ]; then
            echo "UTF-8 BOM:  [$i]"
            sed -i '1s/^.//' "$i"
            ## The following commands work, but may be overkill.
            # dd iflag=skip_bytes skip=3 if=file.srt of=temp.srt
            # dd bs=1 skip=3 if=file.srt of=temp.srt
            # tail -c +32 file.srt > temp.srt
        fi

        if [ -n "$(echo $CODING | grep 'CRLF')" ]; then
            echo "CRLF:       [$i]"
            sed -i 's/\r//g' "$i"
        fi

    done
}

################################################################################
## Audio

## For the sake of simplicity we convert everything to OGG.
## You can easily set output folder to current folder with TC_AUDIO_DEST=".".
TC_AUDIO_DEST="/media/data1/Musics/"

## OGG quality ranges from -1 to 10. If TC_AUDIO_QUAL is 0, bitrate will be set
## automatically according to the source.
TC_AUDIO_QUAL=0

## OGG values.
## -q-1 45 kbit/s
## -q0  64 kbit/s
## -q1  80 kbit/s
## -q2  96 kbit/s
## -q3  112 kbit/s
## -q4  128 kbit/s
## -q5  160 kbit/s
## -q6  192 kbit/s
## -q7  224 kbit/s
## -q8  256 kbit/s
## -q9  320 kbit/s
## -q10 500 kbit/s

## Artists: we use same value for artist and album_artist.

## Genres: since this is not universal by nature, we do not put a genre in tags,
## except for Classical and Soundtrack.
TC_AUDIO_GENRE=""

## Check for
# MP3 CBR
# In-tag Covers
# Track tag with leading zeros
tc_audio_scan()
{
    echo "void"
}

## TEST: move png,jpg and name $ALBUM - Cover.$EXT. if multiple png,jpg, append counter. TEST.
## TEST: tr some chars like ´ to '. TEST.
## TEST: remove useless tags. TEST.
## TEST: dynamic quality. If aac or OGG, do not reencode. If FLAC or WavPack, reencode -q9. TEST.
## TEST: remove cover from tags. TEST.
## TEST: case checking. handle roman numerals. Handle initials. Handle exception list. TEST.
## TEST: if dest exist, append date.

## TODO: Empty composer field.
## TODO: cover resolution check. Should be > 100x100. Above <1000x1000 should give a warning.
## TODO: extract cover from tags if checksum does not match any from current folder.

## TODO: tag parameters.
# -a artist
# -l album
# -t title
# -n track number
# -d date
# -g genre
# -gc genre=classical
# -gs genre=soundtrack

## This function is supposed to work on a per-album basis. Folders will not be
## accepted as argument. This function will work best if all tracks of a folder
## belong to the same album. Theres is no way to handle covers raliably, so you
## should leave the only covers you want to keep in the working folder.
tc_audio_transcode()
{
    ## Get metadata.
    local METADATA
    local STREAM
    STREAM=$(ffmpeg -i "$1" 2>&1)
    METADATA=$(echo "$STREAM" | sed -n '/Metadata/ ! d; /Metada/{b cont}; :cont ; {n;p;b cont}')
    STREAM=$(echo "$STREAM" | grep "Stream")


    local FORMAT
    FORMAT=$(echo "$STREAM" | sed -n '/Audio:/ {s/.*Audio: \([^,]*\),.*/\1/;p}')
    local BITRATE
    BITRATE=$(echo "$STREAM" | sed -n '/kb\/s/ {s/.*, \(.*\) kb\/s/\1/;p}')

    if [ -z "$FORMAT" ]; then
        echo "ERROR: non-audio file."
        return
    fi

    _metadata_filter()
    {
        ## We fix some chars with sed.
        # ’ => '
        # : => -
        
        ## We use the AWK script to set title case. The script contains
        ## exceptions that can be configured.
        awk -f "$HOME/.shell.d/titlecase.awk" \
            <(echo "$METADATA" | sed -n  -e "/\<$1\>/{s/.*$1[^:]* : //g ; s/’/'/g ; s/[ ]*:[ ]*/ - /g ; p; q}")
    }

    local TITLE
    TITLE=$(_metadata_filter "title")
    [ -z "$TITLE" ] && TITLE="Unknown"

    local ARTIST
    ARTIST=$(_metadata_filter "artist")
    [ -z "$ARTIST" ] && ARTIST="Unknown"

    local ALBUM
    ALBUM=$(_metadata_filter "album")
    local ALBUM_ARTIST
    ALBUM_ARTIST=$(_metadata_filter "album_artist")
    local COMPOSER
    COMPOSER=$(_metadata_filter "composer")
    local DISC
    DISC=$(_metadata_filter "disc")
    local GENRE
    GENRE=""

    local TRACK
    TRACK=$(_metadata_filter "track" | sed -e 's/^0*//' -e 's|/.*||')

    local DATE
    DATE=$(_metadata_filter "date")
    local TYER
    TYER=$(_metadata_filter "TYER" | sed -n 's/.*\([[:digit:]]\{4\}\).*/\1/p')
    ## If DATE is not a year, we use TYER if it is a year.
    if [ ${#DATE} -ne 4 ] && [ ${#TYER} -eq 4 ]; then
        DATE="$TYER"
    fi

    ## DEBUG only.
    # echo "[$ALBUM]"
    # echo "[$ALBUM_ARTIST]"
    # echo "[$ARTIST]"
    # echo "[$BITRATE]"
    # echo "[$COMPOSER]"
    # echo "[$DATE]"
    # echo "[$DISC]"
    # echo "[$FORMAT]"
    # echo "[$GENRE]"
    # echo "[$TITLE]"
    # echo "[$TRACK]"
    # echo "[$TYER]"

    ## OUTPUT
    local OUTPUT
    local OUTPUT_TRACK
    local OUTPUT_COVER
    OUTPUT="$TC_AUDIO_DEST/$ARTIST/"
    if [ -n "$ALBUM" ]; then
        [ -n "$DATE" ] && OUTPUT="$OUTPUT$DATE - "
        OUTPUT="$OUTPUT$ALBUM"
    fi

    ## Make sure directory exists.
    mkdir -p "$OUTPUT"
    if [ $? -ne 0 ]; then
        echo "ERROR: could not create output folder"
        return
    fi

    OUTPUT_TRACK="$OUTPUT/$ARTIST"
    if [ -n "$TRACK" ]; then
        ## Make sure track number has two digits.
        if [ ${TRACK} -lt 10 ]; then
            OUTPUT_TRACK="$OUTPUT_TRACK - 0$TRACK"
        else
            OUTPUT_TRACK="$OUTPUT_TRACK - $TRACK" 
        fi
    fi
    OUTPUT_TRACK="$OUTPUT_TRACK - $TITLE"
    ## If file exist, we append a uniq timestamp to the name.
    [ -e "${OUTPUT_TRACK}.ogg" ] && OUTPUT_TRACK="$OUTPUT_TRACK-$(date '+%F-%H%M%S')"

    ## COVER
    local COVER_COUNTER
    OUTPUT_COVER="$OUTPUT/"
    [ -n "$ALBUM" ] && OUTPUT_COVER="$OUTPUT_COVER$ALBUM - "
    for i in $(find "."  \( \
        -iname '*.png' -o \
        -iname '*.jpg' \) ); do

        OUTPUT_COVER="${OUTPUT_COVER}Cover.${i##*.}"
        COVER_COUNTER=1

        ## We copy cover only if it does not already exist.
        if [ ! "$(sha1sum $OUTPUT_COVER | cut -f1 -d' ')" = "$(sha1sum $i | cut -f1 -d' ')" ]; then

            while [ -e "$OUTPUT_COVER" ]; do
                OUTPUT_COVER="${OUTPUT_COVER}Cover $COVER_COUNTER.${i##*.}"
                COVER_COUNTER=$(($COVER_COUNTER+1))
            done

            ## DEBUG only.
            # echo "cp -nv $i [$OUTPUT_COVER]"
            cp -nv "$i" "$OUTPUT_COVER"
            
        fi
    done

    ## TODO: test w/o qual to see default param.
    ## QUALITY
    if [ $TC_AUDIO_QUAL -eq 0 ]; then
        [ $BITRATE -le 45 ]  && TC_AUDIO_QUAL=45k
        [ $BITRATE -gt 45 ]  && TC_AUDIO_QUAL=64k
        [ $BITRATE -gt 64 ]  && TC_AUDIO_QUAL=80k
        [ $BITRATE -gt 80 ]  && TC_AUDIO_QUAL=96k
        [ $BITRATE -gt 96 ]  && TC_AUDIO_QUAL=112k
        [ $BITRATE -gt 112 ] && TC_AUDIO_QUAL=128k
        [ $BITRATE -gt 128 ] && TC_AUDIO_QUAL=160k
        [ $BITRATE -gt 160 ] && TC_AUDIO_QUAL=192k
        [ $BITRATE -gt 192 ] && TC_AUDIO_QUAL=224k
        [ $BITRATE -gt 224 ] && TC_AUDIO_QUAL=256k
        [ $BITRATE -gt 256 ] && TC_AUDIO_QUAL=320k
        [ $BITRATE -gt 320 ] && TC_AUDIO_QUAL=500k
    fi

    ## DEBUG only.
    # echo "FORMAT: [$FORMAT]"
    # echo "BITRATE: [$TC_AUDIO_QUAL]"
    # echo "OUTPUT: [$OUTPUT_TRACK]"

    ## TODO: set -o shwordsplit
    ## Only reencode if not in OGG.
    local OGG_PARAM
    OGG_PARAM="-c:a libvorbis -b:a $TC_AUDIO_QUAL"
    [ "$FORMAT" = "ogg" ] && OGG_PARAM=""

    # ffmpeg -i "$1" $OGG_PARAM \
    ffmpeg -i "$1" -c:a libvorbis -b:a $TC_AUDIO_QUAL -metadata \
        title="$TITLE",artist="$ARTIST",track="$TRACK",date="$DATE",album="$ALBUM",album_artist="$ARTIST",genre="$GENRE",composer="$COMPOSER" \
        "$OUTPUT_TRACK.ogg"
}


################################################################################
## Video

## TODO: audio quality. Copy if AAC or OGG <320k.
## TODO: chapters support. Already OK?
## TODO: crop options.
## TODO: custom mapping.
## TODO: handle srt encoding.
## TODO: option to replace original file.
## TODO: work with -threads option.

## Vars
TC_VIDEO_AUDIO_QUAL=192k

## quality*size ~= 1/speed
# ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo
TC_VIDEO_PRESET=slow

## Overall quality. Logarithmic scale.
# 18 is near perfection.
# 22 is really good compression, while a bit more blurry than the original.
# 20 is a good compromise.
TC_VIDEO_QUAL=20

## x264 tuning (presets).
## Possible values: film, animation, grain, ...
## See x264 --fullhelp.
## No tuning by default.
# TC_VIDEO_TUNE="-tune film"
TC_VIDEO_TUNE=""

## x264 options.
## Possible values: hex, umh...
## me=umh is default. 
# TC_VIDEO_OPTS="-x264opts me=hex"
TC_VIDEO_OPTS=""

tc_video_demux_audio()
{
    ffmpeg -i "$1" -vn -sn -c:a copy -map 0:1 "$2"
}

tc_video_audio2ogg()
{
    echo "================================================================================"
    ffmpeg -threads 4 -i "$1" -vn -c:a libvorbis -b:a $TC_VIDEO_AUDIO_QUAL "${1%.*}-$(date '+%F-%H%M%S').ogg"
}

tc_video_transcode()
{
    _printhelp()
    {
        cat <<EOF
Usage: $1 [OPTIONS] FILES|FOLDERS

Transcode FILES or files found in FOLDERS to .mkv with x264 and ogg. Output
files are the same as the original, with time appended. You can customize
encoding with the TC_* variables.

  -f:  Overwrite existing file if any.
  -h:  Display this help.
  -s:  Sample of ten minutes.
EOF
    }

    ## What to do if file exists:
    # -y overwrite
    # -n do not overwrite.
    local TC_OVERWRITE
    TC_OVERWRITE=-n

    local TC_SAMPLE
    TC_SAMPLE=""

    while getopts ":fhs" opt; do
        case $opt in
            f)
                TC_OVERWRITE=-y
                ;;
            h)
                _printhelp "$0"
                return 1
                ;;
            s)
                TC_SAMPLE="-ss 60 -t 600 -i"
                ;;
            ?) 
                _printhelp "$0"
                return 1
                ;;
            :)
                echo "Missing argument."
                echo "Use $0 -h for help."
                return 1
                ;;
        esac
    done

    shift $(($OPTIND - 1))


    if [ $# -eq 0 ]; then
        tc_transcode .
        return
    fi

    ## The IFS trick will let us use an array of file that can have spaces. Real arrays are much better at it, but in this case the trick is not excessive, and works on all sh shells.
    local OLDIFS
    OLDIFS=$IFS

    ## Zsh compatibility. We need it otherwise word splitting of parameter like
    ## TC_SAMPLE will not work.
    local STATUS
    STATUS="$(set -o | grep 'shwordsplit' | awk '{print $2}')"
    [ "$STATUS" = "off" ] && set -o shwordsplit

    _tc_transcode()
    {
        local IFS
        IFS=$OLDIFS

        echo "================================================================================"
        ffmpeg $TC_OVERWRITE $TC_SAMPLE -i "$1" \
            -c:v libx264 -preset $TC_VIDEO_PRESET -crf $TC_VIDEO_QUAL $TC_VIDEO_TUNE $TC_VIDEO_OPTS \
            -c:a libvorbis -b:a $TC_VIDEO_AUDIO_QUAL \
            -c:s copy \
            -map 0 "${1%.*}-$(date '+%F-%H%M%S').mkv"
    }

    for i in "$@"; do

        ## Argument is a folder. We search for all video files in there.
        if [ -d "$i" ]; then
            
            local IFS
            IFS="
"

            ## TODO: provide max-depth as option.
            for j in $(find "$i"  \( \
                -iname '*.mkv' -o \
                -iname '*.mp4' -o \
                -iname '*.avi' -o \
                -iname '*.webm' -o \
                -iname '*.flv' -o \
                -iname '*.wmv' -o \
                -iname '*.mpg' \) ); do
                 _tc_transcode $j
            done

        ## Argument is a regular file.
        else
            _tc_transcode "$i"
        fi

    done

    ## Restore Zsh previous options. This will not turn off shwordsplit if it
    ## was on before calling the function.
    [ "$STATUS" = "off" ] && set +o shwordsplit
}


################################################################################
## OLD

## High in Handbrake:
# b-adapt=2:rc-lookahead=50:me=umh

## Mine in Handbrake:
# ref=1:weightp=1:subq=2:rc-lookahead=10:trellis=0:8x8dct=0

## Mine with details:
# cabac=1:ref=1:deblock=1:0:0:analyse=0x1:0x111:me=hex:subme=2:psy=1:psy_rd=1.00:0.00:mixed_ref=0:me_range=16:chroma_me=1:trellis=0:8x8dct=0:cqm=0:deadzone=21,11:fast_pskip=1:chroma_qp_offset=0:threads=6:sliced_threads=0:nr=0:decimate=1:interlaced=0:bluray_compat=0:constrained_intra=0:bframes=3:b_pyramid=2:b_adapt=1:b_bias=0:direct=1:weightb=1:open_gop=0:weightp=1:keyint=240:keyint_min=24:scenecut=40:intra_refresh=0:rc_lookahead=10:rc=crf:mbtree=1:crf=20.0:qcomp=0.60:qpmin=3:qpmax=69:qpstep=4:ip_ratio=1.40:aq=1:1.00

## Mine diff with default:
# ref=1:analyse=0x1:0x111:me=hex:subme=2:trellis=0:8x8dct=0:chroma_qp_offset=0:b_adapt=1:direct=1:weightp=1:keyint=240:rc_lookahead=10


## Best for bad quality movies.
# me=hex
