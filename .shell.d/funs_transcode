## -*- mode:sh -*- #
################################################################################
## Shell -- Trancode function set.
## Date 2013-01-19
################################################################################

## Tool list: ffmpeg, recode, titlecase.awk

## Support:
# ffmpeg -codecs
# ffmpeg -formats

## Useful guide:
# http://ffmpeg.org/trac/ffmpeg/wiki/x264EncodingGuide

################################################################################
## Text

tc_text_scan ()
{
    local IFS
    IFS="
"

    for i in $(find . -type f -size -50M -print); do
        echo -n "# "
        file "$i"
        grep -m1 "\`" "$i"
        grep -m1 "oe" "$i"
    done
}

## Confert all 'bad' encoding to UTF-8/LF.
##
## WARNING: It will fail for encoding other than ISO-8859-1 and cp1252.
tc_text_2utf8 ()
{
    local CODING
    local IFS
    IFS="
"

    for i in $(find . -type f -size -50M -print); do
        CODING=$(file "$i")

        if [ -n "$(echo $CODING | grep 'ISO-8859')" ]; then
            echo "ISO-8859:   [$i]"
            recode latin1..utf-8 "$i"

        elif [ -n "$(echo $CODING | grep 'Non-ISO extended-ASCII')" ]; then
            echo "cp1252:     [$i]"
            recode cp1252..utf-8 "$i"

        elif [ -n "$(echo $CODING | grep 'UTF-16 Unicode text')" ]; then
            echo "UTF-16:     [$i]"
            recode utf-16..utf-8 "$i"

        elif [ -n "$(echo $CODING | grep 'UTF-8 Unicode (with BOM)')" ]; then
            echo "UTF-8 BOM:  [$i]"
            sed -i '1s/^.//' "$i"
            ## The following commands work, but may be overkill.
            # dd iflag=skip_bytes skip=3 if=file.srt of=temp.srt
            # dd bs=1 skip=3 if=file.srt of=temp.srt
            # tail -c +32 file.srt > temp.srt
        fi

        if [ -n "$(echo $CODING | grep 'CRLF')" ]; then
            echo "CRLF:       [$i]"
            sed -i 's/\r//g' "$i"
        fi

    done
}

################################################################################
## Audio

## For the sake of simplicity we convert everything to OGG.

## ID3 details : http://en.wikipedia.org/wiki/ID3

## You can easily set output folder to current folder with TC_AUDIO_DEST=".".
TC_AUDIO_DEST="/media/data1/Musics/"

## Check for
# MP3 CBR
# In-tag Covers
# Track tag with leading zeros
tc_audio_scan()
{
    echo "void"
}

tc_audio_info()
{
 
    local METADATA
    METADATA=$(ffmpeg -i "$1" 2>&1 | sed -n '/Metadata/ ! d; /Metada/{b cont}; :cont ; {n;p;b cont}')

    # echo "$METADATA"

    _metadata_filter()
    {
        ## We fix some chars.
        # ’ => '
        # : => -
        echo "$METADATA" | sed -n  -e "/$1/{s/.*$1[^:]* : //g ; s/’/'/g ; s/[ ]*:[ ]*/ - /g ; p; q}"
    }

    local FORMAT
    FORMAT=$(echo "$METADATA" | sed -n '/Stream/{s/.*Audio: \([^,]*\),.*/\1/g;p;q}')

    local BITRATE
    BITRATE=$(echo "$METADATA" | sed -n '/Stream/{s/.*, \(.*\) kb\/s/\1/g;p;q}')

    local COMPOSER
    COMPOSER=$(_metadata_filter "composer")
    local TRACK
    TRACK=$(_metadata_filter "track")
    local DISC
    DISC=$(_metadata_filter "disc")
    local DATE
    DATE=$(_metadata_filter "date")
    local TYER
    TYER=$(_metadata_filter "TYER" | sed -n 's/.*\([[:digit:]]\{4\}\).*/\1/p')
    
    ## If DATE is not a year
    if [ ${#DATE} -ne 4 ] && [ ${#TYER} -eq 4 ]; then
        DATE="$TYER"
    fi

    local GENRE
    GENRE=""
    local ALBUM
    ALBUM=$(_metadata_filter "album")
    local ALBUM_ARTIST
    ALBUM_ARTIST=$(_metadata_filter "album_artist")
    local TITLE
    TITLE=$(_metadata_filter "title")

    echo "[$COMPOSER]"
    echo "[$TRACK]"
    echo "[$DISC]"
    echo "[$DATE]"
    echo "[$TYER]"
    echo "[$GENRE]"
    echo "[$ALBUM]"
    echo "[$ALBUM_ARTIST]"
    echo "[$TITLE]"
    echo "[$FORMAT]"
    echo "[$BITRATE]"
}

## TODO: move png,jpg and name $ALBUM - Cover.$EXT. if multiple png,jpg, append counter. TEST.
## TODO: tr some chars like ´ to '. TEST.
## TODO: remove useless tags.
## TODO: dynamic quality. If aac or OGG, do not reencode. If FLAC or WavPack, reencode -q9. TEST.
## TODO: if dest exist, append date.
## TODO: case checking. handle roman numerals. Handle initials. Handle exception list.
## TODO: extract cover from tags if checksum does not match any from current folder.
## TODO: remove cover from tags. TEST.
## TODO: cover resolution check. Should be > 100x100. Above <1000x1000 should give a warning.

## TODO: tag parameters.
# -a artist
# -l album
# -t title
# -n track number
# -d date

## Note: we use same value for artist and album_artist.

## OGG quality ranges from -1 to 10
## -q-1 45 kbit/s
## -q0  64 kbit/s
## -q1  80 kbit/s
## -q2  96 kbit/s
## -q3  112 kbit/s
## -q4  128 kbit/s
## -q5  160 kbit/s
## -q6  192 kbit/s
## -q7  224 kbit/s
## -q8  256 kbit/s
## -q9  320 kbit/s
## -q10 500 kbit/s
TC_AUDIO_QUAL=0

## Genres: since this is not universal by nature, we do not put a genre in tags, except for Classical and Soundtrack.
## TODO: use parameters.
## Classical: -gc
## Soundtrack: -gs
TC_AUDIO_GENRE=""

## This function is supposed to work on a per-album basis. Folders will not be
## accepted as argument. This function will work best if all tracks of a folder
## belong to the same album. Theres is no way to handle covers raliably, so you
## should leave the only covers you want to keep in the working folder.
tc_audio_transcode()
{
    ## Get metadata.
    local METADATA
    local STREAM
    STREAM=$(ffmpeg -i "$1" 2>&1)
    METADATA=$(echo "$STREAM" | sed -n '/Metadata/ ! d; /Metada/{b cont}; :cont ; {n;p;b cont}')
    STREAM=$(echo "$STREAM" | grep "Stream")

    _metadata_filter()
    {
        ## We fix some chars.
        # ’ => '
        # : => -
        echo "$METADATA" | sed -n  -e "/\<$1\>/{s/.*$1[^:]* : //g ; s/’/'/g ; s/[ ]*:[ ]*/ - /g ; p; q}"
    }

    local TITLE
    TITLE=$(_metadata_filter "title")
    [ -z "$TITLE" ] && TITLE="Unknown"

    local ARTIST
    ARTIST=$(_metadata_filter "artist")
    [ -z "$ARTIST" ] && ARTIST="Unknown"

    local ALBUM
    ALBUM=$(_metadata_filter "album")
    local ALBUM_ARTIST
    ALBUM_ARTIST=$(_metadata_filter "album_artist")
    local COMPOSER
    COMPOSER=$(_metadata_filter "composer")
    local DISC
    DISC=$(_metadata_filter "disc")
    local GENRE
    GENRE=""

    local TRACK
    TRACK=$(_metadata_filter "track" | sed -e 's/^0*//' -e 's|/.*||')

    local DATE
    DATE=$(_metadata_filter "date")
    local TYER
    TYER=$(_metadata_filter "TYER" | sed -n 's/.*\([[:digit:]]\{4\}\).*/\1/p')
    ## If DATE is not a year, we use TYER if it is a year.
    if [ ${#DATE} -ne 4 ] && [ ${#TYER} -eq 4 ]; then
        DATE="$TYER"
    fi

    local FORMAT
    FORMAT=$(echo "$STREAM" | sed 's/.*Audio: \([^,]*\),.*/\1/')
    local BITRATE
    BITRATE=$(echo "$STREAM" | sed 's/.*, \(.*\) kb\/s/\1/')

    ## DEBUG only.
    # echo "[$ALBUM]"
    # echo "[$ALBUM_ARTIST]"
    # echo "[$ARTIST]"
    # echo "[$BITRATE]"
    # echo "[$COMPOSER]"
    # echo "[$DATE]"
    # echo "[$DISC]"
    # echo "[$FORMAT]"
    # echo "[$GENRE]"
    # echo "[$TITLE]"
    # echo "[$TRACK]"
    # echo "[$TYER]"

    ## OUTPUT
    local OUTPUT
    local OUTPUT_TRACK
    local OUTPUT_COVER
    OUTPUT="$TC_AUDIO_DEST/$ARTIST/"
    if [ -n "$ALBUM" ]; then
        [ -n "$DATE" ] && OUTPUT="$OUTPUT$DATE - "
        OUTPUT="$OUTPUT$ALBUM"
    fi

    ## Make sure directory exists.
    mkdir -p "$OUTPUT"
    if [ $? -ne 0 ]; then
        echo "ERROR: could not create output folder"
        return
    fi

    OUTPUT_TRACK="$OUTPUT/$ARTIST"
    if [ -n "$TRACK" ]; then
        ## Make sure track number has two digits.
        if [ ${TRACK} -lt 10 ]; then
            OUTPUT_TRACK="$OUTPUT_TRACK - 0$TRACK"
        else
            OUTPUT_TRACK="$OUTPUT_TRACK - $TRACK" 
        fi
    fi
    OUTPUT_TRACK="$OUTPUT_TRACK - $TITLE"

    ## COVER
    local COVER_COUNTER
    OUTPUT_COVER="$OUTPUT/"
    [ -n "$ALBUM" ] && OUTPUT_COVER="$OUTPUT$ALBUM - "
    for i in $(find "."  \( \
        -iname '*.png' -o \
        -iname '*.jpg' \) ); do

        OUTPUT_COVER="${OUTPUT}Cover.${i##*.}"
        COVER_COUNTER=1

        while [ -e "$OUTPUT_COVER" ]; do
            OUTPUT_COVER="${OUTPUT}Cover $COVER_COUNTER.${i##*.}"
            COVER_COUNTER=$(($COVER_COUNTER+1))
        done

        ## DEBUG only.
        echo "cp -nv $i [$OUTPUT_COVER]"
        # cp -nv "$i" "$OUTPUT_COVER"
    done

    ## QUALITY
    if [ $TC_AUDIO_QUAL -eq 0 ]; then
        [ $BITRATE -le 45 ]  && TC_AUDIO_QUAL=45
        [ $BITRATE -gt 45 ]  && TC_AUDIO_QUAL=64
        [ $BITRATE -gt 64 ]  && TC_AUDIO_QUAL=80
        [ $BITRATE -gt 80 ]  && TC_AUDIO_QUAL=96
        [ $BITRATE -gt 96 ]  && TC_AUDIO_QUAL=112
        [ $BITRATE -gt 112 ] && TC_AUDIO_QUAL=128
        [ $BITRATE -gt 128 ] && TC_AUDIO_QUAL=160
        [ $BITRATE -gt 160 ] && TC_AUDIO_QUAL=192
        [ $BITRATE -gt 192 ] && TC_AUDIO_QUAL=224
        [ $BITRATE -gt 224 ] && TC_AUDIO_QUAL=256
        [ $BITRATE -gt 256 ] && TC_AUDIO_QUAL=320
        [ $BITRATE -gt 320 ] && TC_AUDIO_QUAL=500
    fi

    ## DEBUG only.
    echo "FORMAT: [$FORMAT]"
    echo "BITRATE: [$TC_AUDIO_QUAL]"
    echo "OUTPUT: [$OUTPUT_TRACK]"

    # ffmpeg -i "$1" -c:a libvorbis -b $TC_AUDIO_QUAL \
    #     -metadata \
    #     title="$TITLE" \
    #     artist="$ARTIST" \
    #     track="$TRACK" \
    #     date="$DATE" \
    #     album="$ALBUM" \
    #     album_artist="$ARTIST" \
    #     "$OUTPUT.ogg"
}


################################################################################
## Video

## TODO: audio quality. Copy if AAC or OGG <320k.
## TODO: chapters support. Already OK?
## TODO: crop options.
## TODO: custom mapping.
## TODO: handle srt encoding.
## TODO: option to replace original file.
## TODO: work with -threads option.

## Vars
TC_VIDEO_AUDIO_QUAL=192k

## quality*size ~= 1/speed
# ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, placebo
TC_VIDEO_PRESET=slow

## Overall quality. Logarithmic scale.
# 18 is near perfection.
# 22 is really good compression, while a bit more blurry than the original.
# 20 is a good compromise.
TC_VIDEO_QUAL=20

## x264 tuning (presets).
## Possible values: film, animation, grain, ...
## See x264 --fullhelp.
## No tuning by default.
# TC_VIDEO_TUNE="-tune film"
TC_VIDEO_TUNE=""

## x264 options.
## Possible values: hex, umh...
## me=umh is default. 
# TC_VIDEO_OPTS="-x264opts me=hex"
TC_VIDEO_OPTS=""

tc_video_demux_audio()
{
    ffmpeg -i "$1" -vn -sn -c:a copy -map 0:1 "$2"
}

tc_video_audio2ogg()
{
    echo "================================================================================"
    ffmpeg -threads 4 -i "$1" -vn -c:a libvorbis -b:a $TC_VIDEO_AUDIO_QUAL "${1%.*}-$(date "+%F-%H%M%S").ogg"
}

tc_video_transcode()
{
    _printhelp()
    {
        cat <<EOF
Usage: $1 [OPTIONS] FILES|FOLDERS

Transcode FILES or files found in FOLDERS to .mkv with x264 and ogg. Output
files are the same as the original, with time appended. You can customize
encoding with the TC_* variables.

  -f:  Overwrite existing file if any.
  -h:  Display this help.
  -s:  Sample of ten minutes.
EOF
    }

    ## What to do if file exists:
    # -y overwrite
    # -n do not overwrite.
    local TC_OVERWRITE
    TC_OVERWRITE=-n

    local TC_SAMPLE
    TC_SAMPLE=""

    while getopts ":fhs" opt; do
        case $opt in
            f)
                TC_OVERWRITE=-y
                ;;
            h)
                _printhelp "$0"
                return 1
                ;;
            s)
                TC_SAMPLE="-ss 60 -t 600 -i"
                ;;
            ?) 
                _printhelp "$0"
                return 1
                ;;
            :)
                echo "Missing argument."
                echo "Use $0 -h for help."
                return 1
                ;;
        esac
    done

    shift $(($OPTIND - 1))


    if [ $# -eq 0 ]; then
        tc_transcode .
        return
    fi

    ## The IFS trick will let us use an array of file that can have spaces. Real arrays are much better at it, but in this case the trick is not excessive, and works on all sh shells.
    local OLDIFS
    OLDIFS=$IFS

    ## Zsh compatibility. We need it otherwise word splitting of parameter like
    ## TC_SAMPLE will not work.
    local STATUS
    STATUS="$(set -o | grep 'shwordsplit' | awk '{print $2}')"
    [ "$STATUS" = "off" ] && set -o shwordsplit

    _tc_transcode()
    {
        local IFS
        IFS=$OLDIFS

        echo "================================================================================"
        ffmpeg $TC_OVERWRITE $TC_SAMPLE -i "$1" \
            -c:v libx264 -preset $TC_VIDEO_PRESET -crf $TC_VIDEO_QUAL $TC_VIDEO_TUNE $TC_VIDEO_OPTS \
            -c:a libvorbis -b:a $TC_VIDEO_AUDIO_QUAL \
            -c:s copy \
            -map 0 "${1%.*}-$(date "+%F-%H%M%S").mkv"
    }

    for i in "$@"; do

        ## Argument is a folder. We search for all video files in there.
        if [ -d "$i" ]; then
            
            local IFS
            IFS="
"

            ## TODO: provide max-depth as option.
            for j in $(find "$i"  \( \
                -iname '*.mkv' -o \
                -iname '*.mp4' -o \
                -iname '*.avi' -o \
                -iname '*.webm' -o \
                -iname '*.flv' -o \
                -iname '*.wmv' -o \
                -iname '*.mpg' \) ); do
                 _tc_transcode $j
            done

        ## Argument is a regular file.
        else
            _tc_transcode "$i"
        fi

    done

    ## Restore Zsh previous options. This will not turn off shwordsplit if it
    ## was on before calling the function.
    [ "$STATUS" = "off" ] && set +o shwordsplit
}


################################################################################
## OLD

## High in Handbrake:
# b-adapt=2:rc-lookahead=50:me=umh

## Mine in Handbrake:
# ref=1:weightp=1:subq=2:rc-lookahead=10:trellis=0:8x8dct=0

## Mine with details:
# cabac=1:ref=1:deblock=1:0:0:analyse=0x1:0x111:me=hex:subme=2:psy=1:psy_rd=1.00:0.00:mixed_ref=0:me_range=16:chroma_me=1:trellis=0:8x8dct=0:cqm=0:deadzone=21,11:fast_pskip=1:chroma_qp_offset=0:threads=6:sliced_threads=0:nr=0:decimate=1:interlaced=0:bluray_compat=0:constrained_intra=0:bframes=3:b_pyramid=2:b_adapt=1:b_bias=0:direct=1:weightb=1:open_gop=0:weightp=1:keyint=240:keyint_min=24:scenecut=40:intra_refresh=0:rc_lookahead=10:rc=crf:mbtree=1:crf=20.0:qcomp=0.60:qpmin=3:qpmax=69:qpstep=4:ip_ratio=1.40:aq=1:1.00

## Mine diff with default:
# ref=1:analyse=0x1:0x111:me=hex:subme=2:trellis=0:8x8dct=0:chroma_qp_offset=0:b_adapt=1:direct=1:weightp=1:keyint=240:rc_lookahead=10


## Best for bad quality movies.
# me=hex
